<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2TrancePrivate</title>
    
    <!-- PWA: manifestファイルへのリンクを追加 -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS PWA 互換性メタタグ (互換性向上のため追加) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="P2Trance">

    <style>
        /* ... (元のスタイルシートは省略) ... */
        :root {
            --color-primary: #111827;
            --color-secondary: #6b7280;
            --color-background: #f9fafb;
            --color-white: white;
            --color-red: #dc2626;
            --color-green: #10b981;
            --color-yellow: #d97706;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
            background: var(--color-background);
            min-height: 100vh;
            color: var(--color-primary);
            padding-bottom: 70px; /* フッターの高さ分を確保 */
        }
        
        /* Navigation (タイトルのみ残す) */
        .nav {
            border-bottom: 1px solid #e5e7eb;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            position: sticky;
            top: 0;
            z-index: 50;
        }
        
        .nav-content {
            max-width: 1280px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }
        
        .nav h1 {
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: -0.025em;
            color: var(--color-primary);
        }
        
        /* PWA移行により不要になった要素は非表示 */
        .nav-status, .header {
            display: none;
        }
        
        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 2rem 2rem;
            padding-top: 0rem;
        }
        
        /* Login Section */
        .login-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 70px - 70px); 
            text-align: center;
        }
        
        .login-card {
            background: var(--color-white);
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            padding: 3rem;
            max-width: 400px;
            width: 100%;
        }
        
        .login-card h2 {
            font-size: 2rem;
            font-weight: 300;
            color: var(--color-primary);
            margin-bottom: 1rem;
            letter-spacing: -0.025em;
        }
        
        .login-card p {
            font-size: 1rem;
            color: var(--color-secondary);
            font-weight: 300;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .google-signin-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            width: 100%;
            padding: 0.75rem 1.5rem;
            background: #4285f4;
            color: var(--color-white);
            border: none;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .google-signin-btn:hover {
            background: #3367d6;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
        }
        
        /* Main Content */
        .main-content {
            display: none;
        }
        
        /* Status (フッターに移動) */
        .status-footer {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            font-size: 0.875rem;
        }

        .status-footer .status {
            padding: 0.375rem 0.75rem;
            margin: 0;
        }
        
        .status.disconnected {
            background: #fef2f2;
            color: var(--color-red);
            border: 1px solid #fecaca;
        }
        
        .status.connecting {
            background: #fffbeb;
            color: var(--color-yellow);
            border: 1px solid #fed7aa;
        }
        
        .status.connected {
            background: #f0fdf4;
            color: var(--color-green);
            border: 1px solid #bbf7d0;
        }
        
        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 3rem;
            margin-bottom: 0rem; 
        }
        
        .card {
            background: var(--color-white);
            border-radius: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            overflow: hidden;
            transition: all 0.5s ease;
        }
        
        .card-header {
            border-bottom: 1px solid #f3f4f6;
            padding: 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .card-title {
            font-size: 1.125rem;
            font-weight: 500;
            color: var(--color-primary);
            letter-spacing: -0.025em;
        }
        
        .card-subtitle {
            color: var(--color-secondary);
            font-size: 0.875rem;
            margin-top: 0.25rem;
        }
        
        .card-content {
            padding: 2rem;
        }
        
        /* Message History / Drop Zone / Form Elements (中略) */
        
        /* フッター (新規追加/移動) */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            border-top: 1px solid #e5e7eb;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            z-index: 50;
        }
        
        .footer-content {
            max-width: 1280px;
            margin: 0 auto;
            padding: 0.75rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .footer .user-info {
            display: none; /* 初期は非表示 */
            align-items: center;
            gap: 0.75rem;
        }
        
        .footer .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #e5e7eb;
        }
        
        .footer .logout-btn {
            background: var(--color-red);
            color: var(--color-white);
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
        }

        /* Login時のフッターに配置するボタン */
        .footer .login-btn-container {
            display: none;
        }
        
        .footer .google-signin-btn-footer {
            background: #4285f4;
            color: var(--color-white);
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .footer-content {
                padding: 0.5rem 1rem;
            }
        }
        /* ... (その他のスタイルは元のまま) ... */
    </style>
    <!-- CSS終了 -->
</head>
<body>
    <!-- 
        ★ 修正点: 
        handleSignIn/handleSignOut の定義を、HTML本体が読み込まれる前に配置します。
        これにより、onclick イベントが発火する際に、関数がグローバルスコープで定義済みであることを保証します。
    -->
    <script>
        // ★ 修正点: グローバル関数として定義し、HTMLのonclickから即座にアクセス可能にする
        window.handleSignIn = async function() {
            if (!window.firebaseAuth) {
                // firebaseAuth モジュールがまだロードされていない場合は警告
                console.warn('Firebase認証モジュールがまだ読み込まれていません。ロードを待機中...');
                alert('ログイン処理を開始できませんでした。ページをリロードして再度お試しください。');
                return;
            }
            try {
                const result = await window.firebaseAuth.signIn();
                console.log('ログイン成功:', result.user);
            } catch (error) {
                console.error('ログインエラー:', error);
                alert('ログインに失敗しました: ' + error.message);
            }
        };

        window.handleSignOut = async function() {
            if (!window.firebaseAuth) {
                console.error('Firebase認証モジュールが未定義です。');
                return;
            }
            // ログアウト前にデータベースからPeer IDを削除するロジック（後で定義される peer/currentUser に依存）
            if (window.peer && window.currentUser) {
                const db = window.firebaseAuth.db;
                const devicesRef = db.getDevicesRef(window.currentUser.id);
                const deviceRef = db.getDeviceRef(window.currentUser.id, window.peer.id);
                
                if (window.peerWatcher) {
                    db.onValue(devicesRef, window.peerWatcher); 
                }
                
                await db.remove(deviceRef);
            }
            
            try {
                await window.firebaseAuth.signOut();
                console.log('ログアウト成功');
            } catch (error) {
                console.error('ログアウトエラー:', error);
                alert('ログアウトに失敗しました: ' + error.message);
            }
        };
    </script>
    <!-- Navigation (タイトルのみ) -->
    <nav class="nav">
        <div class="nav-content">
            <h1>P2TrancePrivate</h1>
        </div>
    </nav>

    <!-- Login Section -->
    <div class="login-section" id="loginSection">
        <div class="login-card">
            <h2>P2TrancePrivate</h2>
            <p>Googleアカウントでログインして、安全なP2P通信を開始してください</p>
            <button class="google-signin-btn" onclick="handleSignIn()">
                <!-- SVGアイコン省略 -->
                <svg width="18" height="18" viewBox="0 0 18 18">
                    <path fill="#4285F4" d="M16.51 8H8.98v3h4.3c-.18 1-.74 1.48-1.6 2.04v2.01h2.6a7.8 7.8 0 0 0 2.38-5.88c0-.57-.05-.66-.15-1.18z"/>
                    <path fill="#34A853" d="M8.98 17c2.16 0 3.97-.72 5.3-1.94l-2.6-2.04a4.8 4.8 0 0 1-7.18-2.53H1.83v2.07A8 8 0 0 0 8.98 17z"/>
                    <path fill="#FBBC05" d="M4.5 10.49a4.8 4.8 0 0 1 0-3.07V5.35H1.83a8 8 0 0 0 0 7.28l2.67-2.14z"/>
                    <path fill="#EA4335" d="M8.98 4.72c1.16 0 2.23.4 3.06 1.2l2.3-2.3A8 8 0 0 0 1.83 5.35L4.5 7.42a4.77 4.77 0 0 1 4.48-2.7z"/>
                </svg>
                Googleでログイン
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container main-content" id="mainContent">
        <!-- Main Content -->
        <div class="main-grid">
            <!-- Message & File Section -->
            <div class="card">
                <div class="card-header">
                    <div>
                        <h3 class="card-title">メッセージ & ファイル</h3>
                        <p class="card-subtitle">テキストメッセージと任意のファイル形式を送信</p>
                    </div>
                </div>
                <div class="card-content">
                    <div class="drop-zone" id="dropZone">
                        ファイルをここにドロップするか、下のボタンを使用してください
                    </div>
                    
                    <div class="input-area">
                        <textarea id="messageInput" placeholder="メッセージを入力..." disabled></textarea>
                        <div class="input-buttons">
                            <button class="input-btn file-btn" onclick="selectFile()" title="ファイル選択" disabled id="fileBtn">FILE</button>
                            <button class="input-btn paste-btn" onclick="pasteText()" title="テキスト貼り付け" disabled id="pasteBtn">PASTE</button>
                        </div>
                    </div>
                    
                    <input type="file" id="fileInput" onchange="handleFileSelect(event)">
                    
                    <div id="filePreview" style="display: none;">
                        <div class="preview-container">
                            <div id="previewContainer">
                                <img id="previewImg" class="image-preview" style="display: none;">
                                <div id="fileIcon" class="file-icon" style="display: none;">FILE</div>
                            </div>
                            <div class="file-details">
                                <div id="fileName"></div>
                                <div id="fileSize" class="file-info"></div>
                                <div id="fileType" class="file-info"></div>
                                <button onclick="clearPreview()" class="clear-btn">削除</button>
                            </div>
                        </div>
                    </div>
                    
                    <button onclick="sendMessage()" id="sendBtn" disabled>送信</button>
                    
                    <div class="message-history" id="messageHistory">
                        <!-- 初期メッセージを削除し、空にする -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Image Overlay -->
    <div class="image-overlay" id="imageOverlay" onclick="closeImageOverlay()">
        <img id="overlayImg">
    </div>
    
    <!-- PWA / ステータス / ユーザー情報フッター (修正済み) -->
    <footer class="footer">
        <div class="footer-content">
            <!-- 接続ステータス -->
            <div class="status-footer">
                <div class="status disconnected" id="status">
                    デバイス検索中...
                </div>
            </div>
            
            <!-- ユーザー情報 & ログアウトボタン -->
            <div class="user-info" id="footerUserInfo">
                <img id="footerUserAvatar" class="user-avatar" src="" alt="ユーザーアバター">
                <span id="footerUserName" style="font-size: 0.875rem;"></span>
                <button class="logout-btn" onclick="handleSignOut()">ログアウト</button>
            </div>
            
            <!-- ログインボタン（Login Sectionが表示されているときのみ表示） -->
            <div class="login-btn-container" id="footerLoginBtnContainer">
                <button class="google-signin-btn-footer" onclick="handleSignIn()">
                    Googleでログイン
                </button>
            </div>
        </div>
    </footer>

    <!-- Firebase SDK (モジュール依存のコード) -->
    <script type="module">
        import { getFirebaseConfig } from './firebase-config.js';
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js';
        import { getDatabase, ref, set, onValue, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js';

        // Firebase初期化
        const firebaseConfig = getFirebaseConfig();
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app); 
        
        // Google認証プロバイダーの設定
        const provider = new GoogleAuthProvider();
        provider.setCustomParameters({
            prompt: 'select_account'
        });

        // グローバルオブジェクトにFirebase認証ヘルパーをアタッチ
        window.firebaseAuth = {
            signIn: async () => {
                try {
                    const result = await signInWithPopup(auth, provider);
                    return result;
                } catch (error) {
                    console.warn('ポップアップログインに失敗、リダイレクト方式を試行:', error);
                    const { signInWithRedirect } = await import('https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js');
                    return signInWithRedirect(auth, provider);
                }
            },
            signOut: () => signOut(auth),
            onAuthStateChanged: (callback) => onAuthStateChanged(auth, callback),
            // Realtime Databaseのパス設定
            db: {
                getDeviceRef: (userId, peerId) => ref(db, `usersOnline/${userId}/${peerId}`),
                getDevicesRef: (userId) => ref(db, `usersOnline/${userId}`),
                set,
                remove,
                onValue,
                onDisconnect
            }
        };
        
        // PWA: サービスワーカーの登録 (index.htmlの外部に sw.js が必要です)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
    </script>

    <!-- PeerJS とその他のロジック (通常のスクリプト) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    
    <script>
        // グローバル変数 (window.handleSignOut からアクセスできるように window にアタッチ)
        window.currentUser = null;
        window.peer = null;
        window.connections = new Map();
        let selectedFile = null;
        let onlineUsers = new Set();
        window.peerWatcher = null; 
        
        // DOM要素の取得
        const statusEl = document.getElementById('status');
        const sendBtn = document.getElementById('sendBtn');
        const fileBtn = document.getElementById('fileBtn');
        const pasteBtn = document.getElementById('pasteBtn');
        const messageInput = document.getElementById('messageInput');
        const messageHistory = document.getElementById('messageHistory');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const filePreview = document.getElementById('filePreview');
        const previewImg = document.getElementById('previewImg');
        const fileIcon = document.getElementById('fileIcon');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileType = document.getElementById('fileType');
        const imageOverlay = document.getElementById('imageOverlay');
        const overlayImg = document.getElementById('overlayImg');
        const loginSection = document.getElementById('loginSection');
        const mainContent = document.getElementById('mainContent');

        // フッターの要素
        const footerUserInfo = document.getElementById('footerUserInfo');
        const footerUserName = document.getElementById('footerUserName');
        const footerUserAvatar = document.getElementById('footerUserAvatar');
        const footerLoginBtnContainer = document.getElementById('footerLoginBtnContainer');

        // UIの状態を更新するヘルパー関数
        function updateUI(user) {
            if (user) {
                // ログイン状態
                loginSection.style.display = 'none';
                mainContent.style.display = 'block';
                footerUserInfo.style.display = 'flex';
                footerLoginBtnContainer.style.display = 'none';

                footerUserName.textContent = user.name;
                footerUserAvatar.src = user.picture;

                // P2P接続を開始
                initializeP2P();
            } else {
                // ログアウト状態
                loginSection.style.display = 'flex';
                mainContent.style.display = 'none';
                footerUserInfo.style.display = 'none';
                footerLoginBtnContainer.style.display = 'block';

                // 接続をクリーンアップ
                if (window.peer) {
                    window.peer.destroy();
                    window.peer = null;
                }
                window.connections.clear();
                onlineUsers.clear();
                clearMessageHistory();
            }
        }

        // Firebase認証の初期化と状態監視
        window.addEventListener('DOMContentLoaded', async () => {
            let attempts = 0;
            const maxAttempts = 50; 
            
            while (!window.firebaseAuth && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }

            if (window.firebaseAuth) {
                window.firebaseAuth.onAuthStateChanged((user) => {
                    if (user) {
                        window.currentUser = {
                            id: user.uid,
                            name: user.displayName,
                            email: user.email,
                            picture: user.photoURL
                        };
                    } else {
                        window.currentUser = null;
                    }
                    updateUI(window.currentUser);
                });
            } else {
                console.error("Firebase認証モジュールの読み込みに失敗しました。");
                updateStatus('致命的なエラー: 認証機能が利用できません', 'disconnected');
            }
        });

        async function initializeP2P() {
            updateStatus('P2P接続を初期化中...', 'connecting');
            
            const peerOptions = {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                }
            };
            
            // Peer IDをデバイス固有にすることで、同じアカウントで複数の接続を可能にする
            const deviceSuffix = Math.random().toString(36).substring(2, 8);
            const peerId = 'user-' + window.currentUser.id.substring(0, 12) + '-' + deviceSuffix;
            window.peer = new Peer(peerId, peerOptions);
            
            window.peer.on('open', async (id) => {
                console.log('My peer ID is: ' + id);
                
                // Peer IDを Realtime Database に登録
                const db = window.firebaseAuth.db;
                const deviceRef = db.getDeviceRef(window.currentUser.id, id);
                
                await db.set(deviceRef, {
                    peerId: id,
                    name: navigator.userAgent.substring(0, 30), 
                    timestamp: Date.now()
                });
                // 切断時の削除を設定
                db.onDisconnect(deviceRef).remove();

                updateStatus('他のデバイスを検索中...', 'connecting');
                
                // 自分のデバイスを監視して接続を確立
                startPeerDiscovery(id);
                
                messageInput.disabled = false;
                fileBtn.disabled = false;
                pasteBtn.disabled = false;
            });
            
            window.peer.on('connection', (conn) => {
                setupConnection(conn);
            });
            
            window.peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateStatus('エラーが発生しました: ' + err.message, 'disconnected');
            });
        }
        
        // 自分のアカウントのデバイスのみをディスカバリ
        function startPeerDiscovery(myPeerId) {
            const db = window.firebaseAuth.db;
            const devicesRef = db.getDevicesRef(window.currentUser.id);
            
            // 自分のユーザーIDのノードにあるデバイスリストを監視
            window.peerWatcher = db.onValue(devicesRef, (snapshot) => {
                const devices = snapshot.val();
                if (!devices) return;

                // 自分のデバイス一覧をループして接続を試行
                Object.keys(devices).forEach(peerId => {
                    // 自分自身、または既に接続済みのピアを除外
                    if (peerId !== myPeerId && !window.connections.has(peerId)) {
                        tryConnectToUser(peerId);
                    }
                });
            });
        }
        
        function tryConnectToUser(userId) {
            try {
                const conn = window.peer.connect(userId, { reliable: true });
                setupConnection(conn);
            } catch (err) {
                console.log('Failed to connect to user:', userId);
            }
        }

        function setupConnection(conn) {
            conn.on('open', () => {
                window.connections.set(conn.peer, conn);
                onlineUsers.add(conn.peer);
                
                updateConnectionStatus();
                
                // 初回接続時にユーザー情報を交換
                conn.send({
                    type: 'user_info',
                    user: window.currentUser,
                    timestamp: new Date().toISOString()
                });
            });
            
            conn.on('data', (data) => {
                console.log('Received:', data);
                handleReceivedData(data, conn.peer);
            });
            
            conn.on('close', () => {
                window.connections.delete(conn.peer);
                onlineUsers.delete(conn.peer);
                updateConnectionStatus();
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
                window.connections.delete(conn.peer);
                onlineUsers.delete(conn.peer);
                updateConnectionStatus();
            });
        }

        function updateConnectionStatus() {
            const connectedCount = window.connections.size;
            if (connectedCount > 0) {
                updateStatus(`${connectedCount}人のデバイスと接続済み`, 'connected');
                sendBtn.disabled = false;
            } else {
                updateStatus('他のデバイスを検索中...', 'connecting');
                sendBtn.disabled = true;
            }
        }
        
        function handleReceivedData(data, fromPeer) {
            const timestamp = new Date().toLocaleTimeString();
            
            if (data.type === 'user_info') {
                console.log('User info received from:', fromPeer, data.user);
                return;
            }
            
            if (data.type === 'text') {
                addMessage(data.message, 'received', data.timestamp || timestamp, fromPeer);
            } else if (data.type === 'image') {
                addImageMessage(data.fileData, data.filename, data.filesize, 'received', data.timestamp || timestamp, data.message, fromPeer);
            } else if (data.type === 'file') {
                addFileMessage(data.fileData, data.filename, data.filesize, data.filetype, 'received', data.timestamp || timestamp, data.message, fromPeer);
            }
        }
        
        function broadcastToAllConnections(data) {
            window.connections.forEach((conn, peerId) => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        function sendMessage() {
            const message = messageInput.value.trim();
            const timestamp = new Date().toLocaleTimeString();
            
            if (window.connections.size === 0) return;
            
            if (selectedFile) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const fileData = e.target.result;
                    const isImage = selectedFile.type.startsWith('image/');
                    
                    const data = {
                        type: isImage ? 'image' : 'file',
                        fileData: fileData,
                        filename: selectedFile.name,
                        filesize: formatFileSize(selectedFile.size),
                        filetype: selectedFile.type,
                        timestamp: timestamp
                    };
                    
                    if (message) {
                        data.message = message;
                    }
                    
                    broadcastToAllConnections(data);
                    
                    if (isImage) {
                        addImageMessage(fileData, selectedFile.name, formatFileSize(selectedFile.size), 'sent', timestamp, message);
                    } else {
                        addFileMessage(fileData, selectedFile.name, formatFileSize(selectedFile.size), selectedFile.type, 'sent', timestamp, message);
                    }
                    
                    clearPreview();
                    messageInput.value = '';
                };
                reader.readAsDataURL(selectedFile);
            }
            else if (message) {
                const data = {
                    type: 'text',
                    message: message,
                    timestamp: timestamp
                };
                
                broadcastToAllConnections(data);
                addMessage(message, 'sent', timestamp);
                messageInput.value = '';
            }
        }

        function updateStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        function addMessage(message, type, timestamp, fromPeer = null) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            
            const messageText = document.createElement('div');
            messageText.textContent = message;
            
            // コピーボタンを追加
            const copyBtn = document.createElement('button');
            copyBtn.textContent = 'コピー';
            copyBtn.style.cssText = 'font-size: 0.75rem; padding: 0.25rem 0.5rem; margin-top: 0.5rem; background: rgba(255,255,255,0.3); border: 1px solid rgba(255,255,255,0.5); border-radius: 0.25rem; cursor: pointer; color: inherit;';
            copyBtn.onclick = (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(message).then(() => {
                    copyBtn.textContent = 'コピー済み!';
                    setTimeout(() => copyBtn.textContent = 'コピー', 1500);
                }).catch(() => {
                    copyBtn.textContent = '失敗';
                    setTimeout(() => copyBtn.textContent = 'コピー', 1500);
                });
            };
            
            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            timeEl.textContent = fromPeer ? `${timestamp} - ${fromPeer}` : timestamp;
            
            messageEl.appendChild(messageText);
            messageEl.appendChild(copyBtn);
            messageEl.appendChild(timeEl);
            
            messageHistory.appendChild(messageEl);
            messageHistory.scrollTop = messageHistory.scrollHeight;
        }
        
        function addImageMessage(imageData, filename, filesize, type, timestamp, message = '', fromPeer = null) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type} image-message`;
            
            const imgEl = document.createElement('img');
            imgEl.src = imageData;
            imgEl.onclick = () => showImageOverlay(imageData);
            imgEl.style.maxWidth = '100%';
            imgEl.style.borderRadius = '0.5rem';
            imgEl.style.cursor = 'pointer';
            
            const fileInfoEl = document.createElement('div');
            fileInfoEl.className = 'file-info';
            fileInfoEl.textContent = `${filename} (${filesize})`;
            
            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            timeEl.textContent = fromPeer ? `${timestamp} - ${fromPeer}` : timestamp;
            
            messageEl.appendChild(imgEl);
            messageEl.appendChild(fileInfoEl);
            
            if (message) {
                const messageText = document.createElement('div');
                messageText.textContent = message;
                messageText.style.marginTop = '0.5rem';
                messageEl.appendChild(messageText);
            }

            const saveBtn = document.createElement('button');
            saveBtn.textContent = '保存';
            saveBtn.style.cssText = 'margin-top: 0.5rem; padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #10b981; color: white; border: none; border-radius: 0.375rem; cursor: pointer;';
            saveBtn.onclick = () => downloadFile(imageData, filename);
            messageEl.appendChild(saveBtn);
            
            messageEl.appendChild(timeEl);
            
            messageHistory.appendChild(messageEl);
            messageHistory.scrollTop = messageHistory.scrollHeight;
        }
        
        function addFileMessage(fileData, filename, filesize, filetype, type, timestamp, message = '', fromPeer = null) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type} file-message`;
            
            const fileInfoEl = document.createElement('div');
            fileInfoEl.className = 'file-info-display';
            
            const fileIconEl = document.createElement('div');
            fileIconEl.className = 'file-icon';
            fileIconEl.style.fontSize = '0.75rem';
            fileIconEl.style.fontWeight = 'bold';
            fileIconEl.style.textAlign = 'center';
            fileIconEl.style.marginBottom = '0.75rem';
            fileIconEl.textContent = getFileIcon(filetype);
            
            const fileNameEl = document.createElement('div');
            fileNameEl.style.fontWeight = '600';
            fileNameEl.style.marginBottom = '0.375rem';
            fileNameEl.textContent = filename;
            
            const fileDetailsEl = document.createElement('div');
            fileDetailsEl.className = 'file-info';
            fileDetailsEl.innerHTML = `${getFileTypeName(filetype)} • ${filesize}`;
            
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'file-download';
            downloadBtn.textContent = 'ダウンロード';
            downloadBtn.onclick = () => downloadFile(fileData, filename);
            
            fileInfoEl.appendChild(fileIconEl);
            fileInfoEl.appendChild(fileNameEl);
            fileInfoEl.appendChild(fileDetailsEl);
            fileInfoEl.appendChild(downloadBtn);
            
            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            timeEl.textContent = fromPeer ? `${timestamp} - ${fromPeer}` : timestamp;
            
            messageEl.appendChild(fileInfoEl);
            
            if (message) {
                const messageText = document.createElement('div');
                messageText.textContent = message;
                messageText.style.marginTop = '0.75rem';
                messageText.style.padding = '0.75rem';
                messageText.style.background = 'rgba(255,255,255,0.5)';
                messageText.style.borderRadius = '0.5rem';
                messageEl.appendChild(messageText);
            }
            
            messageEl.appendChild(timeEl);
            
            messageHistory.appendChild(messageEl);
            messageHistory.scrollTop = messageHistory.scrollHeight;
        }
        
        function clearMessageHistory() {
            messageHistory.innerHTML = '';
        }
        
        function selectFile() {
            fileInput.click();
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                selectedFile = file;
                showFilePreview(file);
            }
        }
        
        function showFilePreview(file) {
            const isImage = file.type.startsWith('image/');
            
            if (isImage) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewImg.src = e.target.result;
                    previewImg.style.display = 'block';
                    fileIcon.style.display = 'none';
                };
                reader.readAsDataURL(file);
            } else {
                previewImg.style.display = 'none';
                fileIcon.style.display = 'flex';
                fileIcon.textContent = getFileIcon(file.type);
            }
            
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileType.textContent = getFileTypeName(file.type);
            filePreview.style.display = 'block';
        }
        
        function clearPreview() {
            selectedFile = null;
            filePreview.style.display = 'none';
            fileInput.value = '';
        }
        
        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return 'IMG';
            if (mimeType.startsWith('video/')) return 'VID';
            if (mimeType.includes('pdf')) return 'PDF';
            if (mimeType.includes('word')) return 'DOC';
            if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'XLS';
            if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'PPT';
            if (mimeType.includes('zip') || mimeType.includes('rar') || mimeType.includes('7z')) return 'ZIP';
            if (mimeType.includes('text')) return 'TXT';
            if (mimeType.includes('json') || mimeType.includes('xml')) return 'DATA';
            return 'FILE';
        }
        
        function getFileTypeName(mimeType) {
            const typeMap = {
                'application/pdf': 'PDFドキュメント',
                'application/msword': 'Wordドキュメント',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'Wordドキュメント',
                'application/vnd.ms-excel': 'Excelスプレッドシート',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'Excelスプレッドシート',
                'application/vnd.ms-powerpoint': 'PowerPointプレゼンテーション',
                'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'PowerPointプレゼンテーション',
                'application/zip': 'ZIPアーカイブ',
                'application/x-rar-compressed': 'RARアーカイブ',
                'text/plain': 'テキストファイル',
                'text/csv': 'CSVファイル',
                'application/json': 'JSONファイル',
                'text/xml': 'XMLファイル'
            };
            
            if (mimeType.startsWith('image/')) return '画像ファイル';
            if (mimeType.startsWith('video/')) return '動画ファイル';
            if (mimeType.startsWith('audio/')) return '音声ファイル';
            
            return typeMap[mimeType] || 'ファイル';
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function showImageOverlay(imageData) {
            overlayImg.src = imageData;
            imageOverlay.style.display = 'flex';
        }
        
        function closeImageOverlay() {
            imageOverlay.style.display = 'none';
        }
        
        function downloadFile(fileData, filename) {
            const link = document.createElement('a');
            link.href = fileData;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        async function pasteText() {
            try {
                const text = await navigator.clipboard.readText();
                if (text) {
                    messageInput.value = text;
                    messageInput.focus();
                } else {
                    alert('クリップボードにテキストが見つかりません。');
                }
            } catch (err) {
                console.error('Clipboard access error:', err);
                alert('クリップボードにアクセスできませんでした。ブラウザの許可設定を確認してください。');
            }
        }
        
        // ドラッグ&ドロップ機能
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                selectedFile = file;
                showFilePreview(file);
            }
        });
        
        // Enterキーでメッセージ送信
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Ctrl+Vでテキスト貼り付け
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'v' && connections.size > 0) {
                if (document.activeElement === messageInput) {
                    return;
                }
                e.preventDefault();
                pasteText();
            }
        });
        
        // ページ終了時のクリーンアップ
        window.addEventListener('beforeunload', () => {
            window.connections.forEach(conn => conn.close());
            if (window.peer) {
                // Realtime Database から ID を削除
                if (window.currentUser) {
                    const db = window.firebaseAuth.db;
                    const deviceRef = db.getDeviceRef(window.currentUser.id, window.peer.id);
                    db.remove(deviceRef);
                }
                window.peer.destroy();
            }
        });
    </script>
</body>
</html>
